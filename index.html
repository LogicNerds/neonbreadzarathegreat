<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3i Atlas</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #000;
        }

        @media (min-width: 768px) {
            #gameContainer {
                max-width: 375px;
                max-height: 667px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Base dimensions
        const BASE_WIDTH = 375;
        const BASE_HEIGHT = 667;
        let scale = 1;

        // Game states
        const STATE = {
            TITLE: 'title',
            FACTION_SELECT: 'faction_select',
            PLAYING: 'playing',
            GAME_OVER: 'game_over'
        };

        let gameState = STATE.TITLE;
        let playerFaction = null; // 'earth' or 'comet'
        let playerScore = 0;
        let opponentScore = 0;
        let gameTimer = 0;
        const GAME_DURATION = 45 * 60; // 45 seconds at 60fps

        // Sprite placeholders - Load from GitHub
        const earthSprite = new Image();
        earthSprite.src = 'https://raw.githubusercontent.com/LogicNerds/neonbread3iatlas/main/assets/earth.png';
        
        const cometSprite = new Image();
        cometSprite.src = 'https://raw.githubusercontent.com/LogicNerds/neonbread3iatlas/main/assets/3iatlas.png';

        // Game logo
        const gameLogo = new Image();
        gameLogo.src = 'https://raw.githubusercontent.com/LogicNerds/neonbread3iatlas/main/assets/3iatlaslogo.png';

        // Background music - will be created on first interaction
        let bgMusic = null;

        // Function called directly by Launch Your Attack button
        function launchGame() {
            // Create and play background music immediately on user click
            bgMusic = new Audio('https://raw.githubusercontent.com/LogicNerds/neonbread3iatlas/main/assets/joogs-hyperspace-416314.mp3');
            bgMusic.loop = true;
            bgMusic.volume = 0.4;
            bgMusic.play().catch(e => console.log('Audio play failed:', e));
            
            // Initialize audio context for sound effects
            initAudio();
            
            // Move to faction select
            gameState = STATE.FACTION_SELECT;
        }

        // Player projectiles and effects
        let playerProjectiles = [];
        let opponentProjectiles = [];
        let explosions = [];
        let playerFlares = [];
        let opponentFlares = [];

        // Player state (Earth or Comet)
        let playerY = BASE_HEIGHT / 2;
        let playerCharging = false;
        let playerChargeTime = 0;

        // Player nukes (for Earth - can have multiple in flight)
        let playerNukes = [];

        // Opponent state
        let opponentY = BASE_HEIGHT / 2;
        let opponentDriftDir = 1;
        let opponentAttackTimer = 0;
        let opponentMoveTimer = 0;

        // Touch tracking
        let touchStartY = 0;
        let touchStartTime = 0;
        let activeTouch = null;

        // Audio context for chiptune sounds
        let audioCtx = null;

        // Initialize audio context on first user interaction
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Chiptune sound generators
        function playLaserSound() {
            if (!audioCtx) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // Square wave for retro laser sound
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        function playPlasmaSound() {
            if (!audioCtx) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // Sawtooth wave for plasma
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.2);
        }

        function playNukeLaunchSound() {
            if (!audioCtx) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // Low rumble building up
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(80, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(120, audioCtx.currentTime + 0.15);
            
            gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playExplosionSound() {
            if (!audioCtx) return;
            
            // Create noise buffer for explosion
            const bufferSize = audioCtx.sampleRate * 0.3;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate white noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(2000, audioCtx.currentTime);
            noiseFilter.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            
            noise.start(audioCtx.currentTime);
            noise.stop(audioCtx.currentTime + 0.3);
        }

        function playFlareSound() {
            if (!audioCtx) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // High-pitched whoosh
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(2400, audioCtx.currentTime + 0.12);
            
            gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.12);
        }

        // Colors
        const COLORS = {
            earthBlue: '#00BFFF',
            cometPurple: '#9D00FF',
            laserRed: '#FF0066',
            nukeOrange: '#FF6600',
            plasmaGreen: '#00FF88',
            flareYellow: '#FFFF00',
            bg: '#0a0015',
            stars: '#ffffff'
        };

        // Resize handler
        function resize() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const scaleX = containerWidth / BASE_WIDTH;
            const scaleY = containerHeight / BASE_HEIGHT;
            scale = Math.min(scaleX, scaleY);
            
            canvas.width = BASE_WIDTH * scale;
            canvas.height = BASE_HEIGHT * scale;
            
            ctx.imageSmoothingEnabled = false;
            ctx.scale(scale, scale);
        }

        window.addEventListener('resize', resize);
        resize();

        // Drawing functions
        function drawStarfield() {
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            // Simple stars
            ctx.fillStyle = COLORS.stars;
            for (let i = 0; i < 50; i++) {
                const x = (i * 73) % BASE_WIDTH;
                const y = (i * 97) % BASE_HEIGHT;
                const size = (i % 3) + 1;
                ctx.fillRect(x, y, size, size);
            }
        }

        function drawPixelText(text, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.font = `${size}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText(text, x, y);
        }

        function drawButton(text, x, y, width, height, color, hoverColor) {
            ctx.fillStyle = color;
            ctx.fillRect(x - width/2, y - height/2, width, height);
            ctx.strokeStyle = hoverColor;
            ctx.lineWidth = 3;
            ctx.strokeRect(x - width/2, y - height/2, width, height);
            
            // Support multi-line text (split by newline)
            const lines = text.split('\n');
            if (lines.length > 1) {
                // Multi-line - center vertically
                const lineHeight = 16;
                const totalHeight = lines.length * lineHeight;
                const startY = y - totalHeight / 2 + lineHeight / 2;
                lines.forEach((line, index) => {
                    drawPixelText(line, x, startY + index * lineHeight + 8, 14, '#fff');
                });
            } else {
                // Single line
                drawPixelText(text, x, y + 8, 14, '#fff');
            }
        }

        function drawEarth(x, y, size) {
            // Use sprite if loaded
            if (earthSprite.complete && earthSprite.naturalWidth > 0) {
                const spriteSize = size * 2;
                ctx.drawImage(earthSprite, x - spriteSize/2, y - spriteSize/2, spriteSize, spriteSize);
                return;
            }
            
            // Fallback rendering
            ctx.fillStyle = COLORS.earthBlue;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Glow
            ctx.strokeStyle = COLORS.earthBlue;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Simple land masses
            ctx.fillStyle = '#00AA00';
            ctx.fillRect(x - size/2, y - size/3, size/2, size/3);
            ctx.fillRect(x, y, size/3, size/2);
        }

        function drawComet(x, y, size) {
            // Use sprite if loaded
            if (cometSprite.complete && cometSprite.naturalWidth > 0) {
                const spriteSize = size * 2;
                ctx.drawImage(cometSprite, x - spriteSize/2, y - spriteSize/2, spriteSize, spriteSize);
                return;
            }
            
            // Fallback rendering
            ctx.fillStyle = COLORS.cometPurple;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Glow
            ctx.strokeStyle = COLORS.cometPurple;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Tail particles
            for (let i = 0; i < 5; i++) {
                const tailX = x - (i + 1) * 8;
                const tailY = y + (Math.sin(gameTimer * 0.05 + i) * 4);
                const tailSize = size * (1 - i * 0.15);
                ctx.globalAlpha = 0.6 - i * 0.1;
                ctx.fillStyle = COLORS.cometPurple;
                ctx.fillRect(tailX - tailSize/2, tailY - tailSize/2, tailSize, tailSize);
            }
            ctx.globalAlpha = 1;
        }

        function drawProjectile(proj) {
            if (proj.type === 'nuke') {
                ctx.fillStyle = COLORS.nukeOrange;
                ctx.fillRect(proj.x - 6, proj.y - 6, 12, 12);
                ctx.strokeStyle = '#FF9933';
                ctx.lineWidth = 2;
                ctx.strokeRect(proj.x - 6, proj.y - 6, 12, 12);
            } else if (proj.type === 'laser') {
                ctx.fillStyle = COLORS.laserRed;
                ctx.fillRect(proj.x - 10, proj.y - 3, 20, 6);
                ctx.fillStyle = '#FF3388';
                ctx.fillRect(proj.x - 8, proj.y - 2, 16, 4);
            } else if (proj.type === 'plasma') {
                ctx.fillStyle = COLORS.plasmaGreen;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#00FFAA';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawExplosion(exp) {
            const progress = exp.timer / exp.maxTimer;
            const radius = exp.radius * (1 + progress * 0.5);
            
            ctx.globalAlpha = 1 - progress;
            ctx.fillStyle = exp.color;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawFlare(flare) {
            const progress = flare.timer / flare.maxTimer;
            const radius = 40;
            
            ctx.globalAlpha = 0.3 * (1 - progress);
            ctx.fillStyle = COLORS.flareYellow;
            ctx.beginPath();
            ctx.arc(flare.x, flare.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function drawHUD() {
            // Timer (center top)
            const timeLeft = Math.max(0, Math.ceil((GAME_DURATION - gameTimer) / 60));
            drawPixelText(`${timeLeft}s`, BASE_WIDTH / 2, 30, 12, '#fff');
            
            // Player Score (left)
            const scoreY = 60;
            drawPixelText('YOU', 40, scoreY, 10, '#fff');
            drawPixelText(`${playerScore}`, 40, scoreY + 20, 12, playerFaction === 'earth' ? COLORS.earthBlue : COLORS.cometPurple);
            
            // Opponent Score (right)
            drawPixelText('ENEMY', BASE_WIDTH - 50, scoreY, 10, '#fff');
            drawPixelText(`${opponentScore}`, BASE_WIDTH - 50, scoreY + 20, 12, playerFaction === 'earth' ? COLORS.cometPurple : COLORS.earthBlue);
        }

        function drawControls() {
            const controlY = BASE_HEIGHT - 90;
            
            if (playerFaction === 'earth') {
                // Nuke button (left)
                drawButton('NUKE', 80, controlY, 130, 60, COLORS.nukeOrange, '#FF9933');
                
                // Detonate button (right) - shows number of nukes ready
                const detonateText = playerNukes.length > 0 ? `DET (${playerNukes.length})` : 'DET';
                const detonateColor = playerNukes.length > 0 ? '#FF3388' : '#663344';
                drawButton(detonateText, BASE_WIDTH - 80, controlY, 130, 60, detonateColor, '#FF6688');
                
                // Flare instructions
                drawPixelText('SWIPE UP FOR FLARE', BASE_WIDTH/2, controlY - 40, 8, '#888');
            } else {
                // Laser button (left)
                drawButton('LASER', 80, controlY, 130, 60, COLORS.laserRed, '#FF3388');
                
                // Plasma button (right) - shows charge
                const plasmaColor = playerCharging ? '#00FFAA' : COLORS.plasmaGreen;
                drawButton('PLASMA', BASE_WIDTH - 80, controlY, 130, 60, plasmaColor, '#00FFAA');
                
                // Swipe instructions
                drawPixelText('SWIPE TO MOVE', BASE_WIDTH/2, controlY - 40, 8, '#888');
            }
        }

        // Title screen
        function drawTitleScreen() {
            drawStarfield();
            
            // Draw logo if loaded, otherwise fallback to text
            if (gameLogo.complete && gameLogo.naturalWidth > 0) {
                const logoWidth = 280;
                const logoHeight = (gameLogo.naturalHeight / gameLogo.naturalWidth) * logoWidth;
                ctx.drawImage(gameLogo, BASE_WIDTH/2 - logoWidth/2, 100, logoWidth, logoHeight);
            } else {
                // Fallback text
                drawPixelText('3i Atlas', BASE_WIDTH/2, 150, 24, COLORS.cometPurple);
            }
            
            // Draw small earth and comet
            drawEarth(BASE_WIDTH/2 - 60, 250, 30);
            drawComet(BASE_WIDTH/2 + 60, 250, 30);
            
            drawButton('Launch Your Attack', BASE_WIDTH/2, 400, 280, 70, COLORS.laserRed, '#FF3388');
            
            drawPixelText('Neon Bread Studios Â© 2025', BASE_WIDTH/2, BASE_HEIGHT - 30, 12, '#666');
        }

        // Faction selection screen
        function drawFactionSelect() {
            drawStarfield();
            
            drawPixelText('Choose Your Side', BASE_WIDTH/2, 120, 16, '#fff');
            
            // Earth button
            drawEarth(BASE_WIDTH/2 - 80, 280, 40);
            drawButton('Play as\nEarth', BASE_WIDTH/2 - 80, 370, 140, 70, COLORS.earthBlue, '#00DDFF');
            
            // Comet button
            drawComet(BASE_WIDTH/2 + 80, 280, 40);
            drawButton('Play as\n3i Atlas', BASE_WIDTH/2 + 80, 370, 140, 70, COLORS.cometPurple, '#BB00FF');
        }

        // Game over screen
        function drawGameOver() {
            drawStarfield();
            
            // Determine winner by score
            let victory = false;
            let message = '';
            
            if (playerScore > opponentScore) {
                victory = true;
                message = 'VICTORY!';
            } else if (opponentScore > playerScore) {
                victory = false;
                message = 'DEFEAT!';
            } else {
                message = 'DRAW!';
            }
            
            const color = victory ? '#00FF00' : (message === 'DRAW!' ? '#FFFF00' : '#FF0000');
            
            drawPixelText(message, BASE_WIDTH/2, 150, 24, color);
            
            // Show final scores
            drawPixelText(`Your Score: ${playerScore}`, BASE_WIDTH/2, 220, 12, '#fff');
            drawPixelText(`Enemy Score: ${opponentScore}`, BASE_WIDTH/2, 250, 12, '#fff');
            
            drawButton('Play Again', BASE_WIDTH/2, 350, 240, 60, COLORS.laserRed, '#FF3388');
            
            // Play More Games link
            drawPixelText('Play More Games!', BASE_WIDTH/2, 480, 10, '#00DDFF');
        }

        // Gameplay
        function startGame(faction) {
            playerFaction = faction;
            gameState = STATE.PLAYING;
            playerScore = 0;
            opponentScore = 0;
            gameTimer = 0;
            playerProjectiles = [];
            opponentProjectiles = [];
            explosions = [];
            playerFlares = [];
            opponentFlares = [];
            playerNukes = [];
            playerCharging = false;
            playerChargeTime = 0;
            
            // Position player and opponent
            if (faction === 'earth') {
                playerY = BASE_HEIGHT / 2;
                opponentY = BASE_HEIGHT / 2;
            } else {
                playerY = BASE_HEIGHT / 2;
                opponentY = BASE_HEIGHT / 2;
            }
        }

        function fireNuke() {
            initAudio();
            playNukeLaunchSound();
            
            const startX = 80;
            const startY = BASE_HEIGHT / 2;
            const targetX = BASE_WIDTH - 80;
            const targetY = opponentY;
            
            // Calculate arc trajectory toward opponent
            const dx = targetX - startX;
            const dy = targetY - startY;
            
            playerNukes.push({
                x: startX,
                y: startY,
                vx: dx / 50, // Horizontal speed to reach target
                vy: -6 // Initial upward velocity for arc
            });
        }

        function detonateNuke() {
            // Detonate oldest nuke (first in array)
            if (playerNukes.length === 0) return;
            
            const nuke = playerNukes.shift(); // Remove and get first nuke
            createExplosion(nuke.x, nuke.y, 50, COLORS.nukeOrange);
            checkNukeDamage(nuke.x, nuke.y);
        }

        function fireLaser() {
            initAudio();
            playLaserSound();
            
            playerProjectiles.push({
                type: 'laser',
                x: 80,
                y: playerY,
                vx: 8,
                vy: 0
            });
        }

        function fireFlare() {
            initAudio();
            playFlareSound();
            
            // Create multiple flare zones in an arc to the right of Earth
            const earthX = 80;
            const earthY = BASE_HEIGHT / 2;
            
            for (let i = 0; i < 3; i++) {
                const angle = (Math.PI / 6) * (i - 1); // -30, 0, +30 degrees
                const distance = 60;
                playerFlares.push({
                    x: earthX + Math.cos(angle) * distance,
                    y: earthY + Math.sin(angle) * distance,
                    timer: 0,
                    maxTimer: 90
                });
            }
        }

        function startPlasmaCharge() {
            playerCharging = true;
            playerChargeTime = 0;
        }

        function releasePlasma() {
            if (!playerCharging) return;
            
            initAudio();
            playPlasmaSound();
            
            const chargeRatio = Math.min(playerChargeTime / 30, 1);
            const power = 4 + chargeRatio * 4;
            
            playerProjectiles.push({
                type: 'plasma',
                x: 80,
                y: playerY,
                vx: power,
                vy: -3 - chargeRatio * 2,
                gravity: 0.15
            });
            
            playerCharging = false;
            playerChargeTime = 0;
        }

        function createExplosion(x, y, radius, color) {
            initAudio();
            playExplosionSound();
            
            explosions.push({
                x, y, radius, color,
                timer: 0,
                maxTimer: 20
            });
            
            // Screen shake
            canvas.style.transform = `translate(${Math.random() * 4 - 2}px, ${Math.random() * 4 - 2}px)`;
            setTimeout(() => canvas.style.transform = '', 100);
        }

        function checkNukeDamage(x, y) {
            const opX = BASE_WIDTH - 80;
            const opY = playerFaction === 'earth' ? opponentY : BASE_HEIGHT / 2;
            const dist = Math.sqrt((x - opX) ** 2 + (y - opY) ** 2);
            
            // Check if in opponent's flare protection (defender's flares)
            let inFlare = false;
            for (let flare of opponentFlares) {
                const flareDist = Math.sqrt((x - flare.x) ** 2 + (y - flare.y) ** 2);
                if (flareDist < 40) {
                    inFlare = true;
                    break;
                }
            }
            
            let points = 0;
            if (dist < 30) {
                points = 10; // Direct hit
            } else if (dist < 50) {
                points = 5; // Indirect blast
            }
            
            // Flare reduces points by 2
            if (inFlare && points > 0) {
                points = Math.max(0, points - 2);
            }
            
            playerScore += points;
        }

        function checkOpponentNukeDamage(x, y) {
            const playerX = 80;
            const targetY = playerFaction === 'earth' ? BASE_HEIGHT / 2 : playerY;
            const dist = Math.sqrt((x - playerX) ** 2 + (y - targetY) ** 2);
            
            // Check if in player's flare protection (defender's flares)
            let inFlare = false;
            for (let flare of playerFlares) {
                const flareDist = Math.sqrt((x - flare.x) ** 2 + (y - flare.y) ** 2);
                if (flareDist < 40) {
                    inFlare = true;
                    break;
                }
            }
            
            let points = 0;
            if (dist < 40) {
                points = 10; // Direct hit - increased from 30
            } else if (dist < 70) {
                points = 5; // Indirect blast - increased from 50
            }
            
            // Flare reduces points by 2
            if (inFlare && points > 0) {
                points = Math.max(0, points - 2);
            }
            
            opponentScore += points;
        }

        function checkProjectileHit(proj, targetX, targetY, isPlayerProjectile) {
            const dist = Math.sqrt((proj.x - targetX) ** 2 + (proj.y - targetY) ** 2);
            
            // Check defender's flare protection
            const defendingFlares = isPlayerProjectile ? opponentFlares : playerFlares;
            let inFlare = false;
            for (let flare of defendingFlares) {
                const flareDist = Math.sqrt((proj.x - flare.x) ** 2 + (proj.y - flare.y) ** 2);
                if (flareDist < 40) {
                    inFlare = true;
                    break;
                }
            }
            
            if (proj.type === 'laser') {
                if (dist < 25) {
                    createExplosion(proj.x, proj.y, 20, COLORS.laserRed);
                    let points = 3; // Laser hit
                    if (inFlare) {
                        points = Math.max(0, points - 2); // Flare reduces by 2
                    }
                    // Award points to whoever shot it
                    if (isPlayerProjectile) {
                        playerScore += points;
                    } else {
                        opponentScore += points;
                    }
                    return true;
                }
            } else if (proj.type === 'plasma') {
                if (dist < 30) {
                    createExplosion(proj.x, proj.y, 35, COLORS.plasmaGreen);
                    let points = 15; // Plasma hit
                    if (inFlare) {
                        points = Math.max(0, points - 2); // Flare reduces by 2
                    }
                    // Award points to whoever shot it
                    if (isPlayerProjectile) {
                        playerScore += points;
                    } else {
                        opponentScore += points;
                    }
                    return true;
                }
            } else if (proj.type === 'nuke') {
                // Handled separately
            }
            
            return false;
        }

        // AI behavior
        function updateOpponentAI() {
            opponentAttackTimer++;
            opponentMoveTimer++;
            
            if (playerFaction === 'earth') {
                // Opponent is comet - fires lasers and plasma
                // More erratic drift up/down
                if (opponentMoveTimer % 60 < 30) {
                    opponentY += 1.2; // Faster movement
                } else {
                    opponentY -= 1.2;
                }
                opponentY = Math.max(100, Math.min(BASE_HEIGHT - 200, opponentY));
                
                // Fire laser - reduced by 20% (45 -> 56 frames)
                if (opponentAttackTimer % 56 === 0) {
                    playLaserSound();
                    opponentProjectiles.push({
                        type: 'laser',
                        x: BASE_WIDTH - 80,
                        y: opponentY,
                        vx: -8,
                        vy: 0
                    });
                }
                
                // Fire plasma blob - reduced by 20% (85 -> 106 frames)
                if (opponentAttackTimer % 106 === 0) {
                    playPlasmaSound();
                    opponentProjectiles.push({
                        type: 'plasma',
                        x: BASE_WIDTH - 80,
                        y: opponentY,
                        vx: -5,
                        vy: -4,
                        gravity: 0.15
                    });
                }
            } else {
                // Opponent is earth - fires nukes and flares
                // Slow drift left/right
                if (opponentMoveTimer % 180 < 90) {
                    // Slight movement would be here but Earth stays mostly stationary
                }
                
                // Calculate time progression once for this AI update
                const timeElapsed = gameTimer / 60; // in seconds
                const timeProgress = Math.min(timeElapsed / 30, 1); // 0 to 1 over 30 seconds
                
                // Fire nuke with escalating aggression based on time elapsed
                // Starts slow, becomes aggressive by 30 seconds
                // Reduced by 20% from original
                
                // Escalating fire rate: starts at 1.6% chance, ramps up to 9.6% by 30 seconds (was 2% -> 12%)
                const baseFireRate = 0.016 + (timeProgress * 0.08); // 1.6% -> 9.6%
                const shouldFireNuke = Math.random() < baseFireRate;
                
                if (shouldFireNuke) {
                    playNukeLaunchSound();
                    
                    const startX = BASE_WIDTH - 80;
                    const startY = BASE_HEIGHT / 2;
                    const targetX = 80;
                    const targetY = playerFaction === 'comet' ? playerY : BASE_HEIGHT / 2;
                    
                    // Calculate trajectory to reach target
                    const distance = Math.abs(targetX - startX);
                    const heightDiff = targetY - startY;
                    
                    // Less randomness as time goes on - more precise aiming
                    const aimPrecision = 1 - (timeProgress * 0.6); // 1.0 -> 0.4
                    const vxVariation = (-0.5 + Math.random() * 1.0) * aimPrecision;
                    const vyVariation = (-0.5 + Math.random() * 1.0) * aimPrecision;
                    
                    const nuke = {
                        type: 'nuke',
                        x: startX,
                        y: startY,
                        vx: -5.5 + vxVariation,
                        vy: -5 - (heightDiff / 80) + vyVariation,
                        detonateTimer: 70 + Math.floor(Math.random() * 15),
                        // Store time progress for smarter detonation
                        smartDetonate: timeProgress > 0.5 // After 15 seconds, use smart detonation
                    };
                    opponentProjectiles.push(nuke);
                }
                
                // Launch flare with escalating frequency
                // Flare interval: starts every 60 frames, ramps to every 36 frames (was 50 -> 30, now 20% slower)
                const flareInterval = Math.floor(60 - (timeProgress * 24)); // 60 -> 36
                
                if (opponentAttackTimer % flareInterval === 0) {
                    playFlareSound();
                    
                    const earthX = BASE_WIDTH - 80;
                    const earthY = BASE_HEIGHT / 2;
                    
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.PI + (Math.PI / 6) * (i - 1); // Mirror for right side
                        const distance = 60;
                        opponentFlares.push({
                            x: earthX + Math.cos(angle) * distance,
                            y: earthY + Math.sin(angle) * distance,
                            timer: 0,
                            maxTimer: 90
                        });
                    }
                }
            }
        }

        function updateGame() {
            gameTimer++;
            
            // Check if time expired - winner is whoever dealt more damage
            if (gameTimer >= GAME_DURATION) {
                gameState = STATE.GAME_OVER;
                return;
            }
            
            // Update opponent AI
            updateOpponentAI();
            
            // Update player nukes (for Earth)
            for (let i = playerNukes.length - 1; i >= 0; i--) {
                const nuke = playerNukes[i];
                nuke.x += nuke.vx;
                nuke.y += nuke.vy;
                nuke.vy += 0.3; // gravity
                
                // Auto-detonate if off screen
                if (nuke.x > BASE_WIDTH || nuke.y > BASE_HEIGHT || nuke.x < 0 || nuke.y < 0) {
                    createExplosion(nuke.x, nuke.y, 50, COLORS.nukeOrange);
                    checkNukeDamage(nuke.x, nuke.y);
                    playerNukes.splice(i, 1);
                }
            }
            
            // Update player charging
            if (playerCharging) {
                playerChargeTime++;
            }
            
            // Update player projectiles
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const proj = playerProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                if (proj.gravity) {
                    proj.vy += proj.gravity;
                }
                
                // Check hit on opponent
                const opX = BASE_WIDTH - 80;
                const opY = opponentY;
                if (checkProjectileHit(proj, opX, opY, true)) {
                    playerProjectiles.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (proj.x > BASE_WIDTH || proj.y > BASE_HEIGHT || proj.x < 0 || proj.y < 0) {
                    playerProjectiles.splice(i, 1);
                }
            }
            
            // Update opponent projectiles
            for (let i = opponentProjectiles.length - 1; i >= 0; i--) {
                const proj = opponentProjectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                if (proj.gravity) {
                    proj.vy += proj.gravity;
                }
                
                // Nukes also have gravity
                if (proj.type === 'nuke') {
                    proj.vy += 0.3; // Apply gravity to nukes
                    
                    // Opponent Earth detonates nukes when close to player (only when player is Comet)
                    if (playerFaction === 'comet') {
                        const playerX = 80;
                        const distToPlayer = Math.sqrt((proj.x - playerX) ** 2 + (proj.y - playerY) ** 2);
                        
                        // Detonation distance gets smaller (more precise) with smart nukes
                        if (!proj.detonationDistance) {
                            if (proj.smartDetonate) {
                                // Late game: very precise, direct hits
                                proj.detonationDistance = 20 + Math.random() * 25; // 20-45 pixels
                            } else {
                                // Early game: more lenient
                                proj.detonationDistance = 30 + Math.random() * 30; // 30-60 pixels
                            }
                        }
                        
                        // Track if we're getting closer or moving away
                        if (!proj.lastDist) proj.lastDist = distToPlayer;
                        const movingAway = distToPlayer > proj.lastDist;
                        proj.lastDist = distToPlayer;
                        
                        // Smart nukes detonate at optimal moment
                        if (proj.smartDetonate) {
                            // Late game: detonate RIGHT at closest approach for maximum direct hits
                            const shouldDetonate = 
                                distToPlayer < proj.detonationDistance || 
                                (movingAway && distToPlayer < 50) || // Detonate immediately when starting to move away
                                proj.x < 25 || 
                                proj.detonateTimer < 3;
                            
                            if (shouldDetonate) {
                                createExplosion(proj.x, proj.y, 50, COLORS.nukeOrange);
                                checkOpponentNukeDamage(proj.x, proj.y);
                                opponentProjectiles.splice(i, 1);
                                continue;
                            }
                        } else {
                            // Early game: standard detonation
                            const shouldDetonate = 
                                distToPlayer < proj.detonationDistance || 
                                (movingAway && distToPlayer < 80) ||
                                proj.x < 30 || 
                                proj.detonateTimer < 5;
                            
                            if (shouldDetonate) {
                                createExplosion(proj.x, proj.y, 50, COLORS.nukeOrange);
                                checkOpponentNukeDamage(proj.x, proj.y);
                                opponentProjectiles.splice(i, 1);
                                continue;
                            }
                        }
                    } else {
                        // When player is Earth, auto-detonate based on timer only
                        proj.detonateTimer--;
                        if (proj.detonateTimer <= 0) {
                            createExplosion(proj.x, proj.y, 50, COLORS.nukeOrange);
                            checkOpponentNukeDamage(proj.x, proj.y);
                            opponentProjectiles.splice(i, 1);
                            continue;
                        }
                    }
                }
                
                // Nuke timer countdown (for comet mode)
                if (proj.type === 'nuke' && playerFaction === 'comet') {
                    proj.detonateTimer--;
                }
                
                // Check hit on player
                const playerX = 80;
                const targetY = playerFaction === 'earth' ? BASE_HEIGHT / 2 : playerY;
                if (checkProjectileHit(proj, playerX, targetY, false)) {
                    opponentProjectiles.splice(i, 1);
                    continue;
                }
                
                // Remove if off screen
                if (proj.x < 0 || proj.y > BASE_HEIGHT || proj.x > BASE_WIDTH || proj.y < 0) {
                    opponentProjectiles.splice(i, 1);
                }
            }
            
            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].timer++;
                if (explosions[i].timer >= explosions[i].maxTimer) {
                    explosions.splice(i, 1);
                }
            }
            
            // Update player flares
            for (let i = playerFlares.length - 1; i >= 0; i--) {
                playerFlares[i].timer++;
                if (playerFlares[i].timer >= playerFlares[i].maxTimer) {
                    playerFlares.splice(i, 1);
                }
            }
            
            // Update opponent flares
            for (let i = opponentFlares.length - 1; i >= 0; i--) {
                opponentFlares[i].timer++;
                if (opponentFlares[i].timer >= opponentFlares[i].maxTimer) {
                    opponentFlares.splice(i, 1);
                }
            }
            
            // Game ends only when timer expires (no HP checks)
        }

        function drawGame() {
            drawStarfield();
            
            // Draw flares first (background)
            playerFlares.forEach(drawFlare);
            opponentFlares.forEach(drawFlare);
            
            // Draw player
            const playerX = 80;
            if (playerFaction === 'earth') {
                drawEarth(playerX, BASE_HEIGHT / 2, 35);
            } else {
                drawComet(playerX, playerY, 35);
            }
            
            // Draw opponent
            const opponentX = BASE_WIDTH - 80;
            if (playerFaction === 'earth') {
                drawComet(opponentX, opponentY, 35);
            } else {
                drawEarth(opponentX, BASE_HEIGHT / 2, 35); // Earth is always at center
            }
            
            // Draw player nukes
            playerNukes.forEach(nuke => {
                ctx.fillStyle = COLORS.nukeOrange;
                ctx.fillRect(nuke.x - 6, nuke.y - 6, 12, 12);
                ctx.strokeStyle = '#FF9933';
                ctx.lineWidth = 2;
                ctx.strokeRect(nuke.x - 6, nuke.y - 6, 12, 12);
            });
            
            // Draw projectiles
            playerProjectiles.forEach(drawProjectile);
            opponentProjectiles.forEach(drawProjectile);
            
            // Draw explosions
            explosions.forEach(drawExplosion);
            
            // Draw HUD and controls
            drawHUD();
            drawControls();
        }

        // Main render loop
        function render() {
            ctx.clearRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            
            if (gameState === STATE.TITLE) {
                drawTitleScreen();
            } else if (gameState === STATE.FACTION_SELECT) {
                drawFactionSelect();
            } else if (gameState === STATE.PLAYING) {
                updateGame();
                drawGame();
            } else if (gameState === STATE.GAME_OVER) {
                drawGameOver();
            }
            
            requestAnimationFrame(render);
        }

        // Touch/click handlers
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0] || e.changedTouches[0];
            return {
                x: (touch.clientX - rect.left) / scale,
                y: (touch.clientY - rect.top) / scale
            };
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) / scale,
                y: (e.clientY - rect.top) / scale
            };
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            handleInput(pos, 'start');
            touchStartY = pos.y;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState === STATE.PLAYING) {
                const pos = getTouchPos(e);
                const deltaY = touchStartY - pos.y; // Positive means swipe up
                
                if (playerFaction === 'comet') {
                    // Comet swipe movement
                    playerY += (pos.y - touchStartY) * 0.3;
                    playerY = Math.max(100, Math.min(BASE_HEIGHT - 200, playerY));
                    touchStartY = pos.y;
                } else if (playerFaction === 'earth') {
                    // Earth swipe up for flare
                    if (deltaY > 50) { // Swipe up threshold
                        fireFlare();
                        touchStartY = pos.y; // Reset to prevent multiple fires
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            handleInput(pos, 'end');
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            handleInput(pos, 'start');
        }

        function handleMouseUp(e) {
            const pos = getMousePos(e);
            handleInput(pos, 'end');
        }

        function handleInput(pos, phase) {
            const controlY = BASE_HEIGHT - 90;
            
            if (gameState === STATE.TITLE) {
                // Launch button - calls launchGame function
                if (pos.y > 365 && pos.y < 435 && pos.x > 47.5 && pos.x < 327.5 && phase === 'start') {
                    launchGame();
                }
            } else if (gameState === STATE.FACTION_SELECT) {
                // Earth button (left)
                if (pos.y > 335 && pos.y < 405 && pos.x > 10 && pos.x < 150 && phase === 'start') {
                    startGame('earth');
                }
                // Comet button (right)
                if (pos.y > 335 && pos.y < 405 && pos.x > 225 && pos.x < 375 && phase === 'start') {
                    startGame('comet');
                }
            } else if (gameState === STATE.PLAYING) {
                if (playerFaction === 'earth') {
                    // Nuke button (left)
                    if (pos.x < 145 && pos.y > controlY - 30 && pos.y < controlY + 30) {
                        if (phase === 'start') {
                            fireNuke();
                        }
                    }
                    // Detonate button (right)
                    if (pos.x > 230 && pos.y > controlY - 30 && pos.y < controlY + 30) {
                        if (phase === 'start') {
                            detonateNuke();
                        }
                    }
                } else {
                    // Laser button (left)
                    if (pos.x < 145 && pos.y > controlY - 30 && pos.y < controlY + 30) {
                        if (phase === 'start') {
                            fireLaser();
                        }
                    }
                    // Plasma button (right) - long press
                    if (pos.x > 230 && pos.y > controlY - 30 && pos.y < controlY + 30) {
                        if (phase === 'start') {
                            startPlasmaCharge();
                        } else if (phase === 'end') {
                            releasePlasma();
                        }
                    }
                }
            } else if (gameState === STATE.GAME_OVER) {
                // Play again button
                if (pos.y > 320 && pos.y < 380 && pos.x > 67.5 && pos.x < 307.5 && phase === 'start') {
                    // Stop music for restart
                    if (bgMusic) {
                        bgMusic.pause();
                        bgMusic.currentTime = 0;
                    }
                    gameState = STATE.TITLE;
                }
                // Play More Games link
                if (pos.y > 465 && pos.y < 495 && phase === 'start') {
                    window.location.href = 'https://www.neon-bread.com';
                }
            }
        }

        // Start the game loop
        render();
    </script>
</body>
</html>
